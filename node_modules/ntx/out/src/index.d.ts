export interface TaskEnvironment {
    readonly name: string;
}
export interface Task<T> {
    readonly name: string | null;
    withName(name: string | null): Task<T>;
    run(env: TaskEnvironment): Promise<T>;
    then<U>(this: Task<void>, continuation: Task<U>): Task<U>;
    let<U>(continuation: (value: T) => Task<U>): Task<U>;
    watch(this: Task<void>, fileName: string): Task<never>;
    start(this: Task<void>): void;
}
export declare class ProcessExitCodeError extends Error {
    readonly code: number;
    readonly signal: string;
    constructor(code: number, signal: string);
}
/** @internal */
export declare const _makeOnChange: <T>(f: (xs: readonly T[]) => Promise<void>) => (x: T, reject: (reason?: any) => void) => void;
export declare const sleep: (ms: number) => Task<void>;
export { all };
declare function all(tasks: Task<void>[]): Task<void>;
declare function all<T1, T2>(tasks: [Task<T1>, Task<T2>]): Task<[T1, T2]>;
declare function all<T1, T2, T3>(tasks: [Task<T1>, Task<T2>, Task<T3>]): Task<[T1, T2, T3]>;
declare function all<T1, T2, T3, T4>(tasks: [Task<T1>, Task<T2>, Task<T3>, Task<T4>]): Task<[T1, T2, T3, T4]>;
declare function all<T>(tasks: Task<T>[]): Task<T[]>;
declare function all(...tasks: Task<void>[]): Task<void>;
declare function all<T1, T2>(task1: Task<T1>, task2: Task<T2>): Task<[T1, T2]>;
declare function all<T1, T2, T3>(task1: Task<T1>, task2: Task<T2>, task3: Task<T3>): Task<[T1, T2, T3]>;
declare function all<T1, T2, T3, T4>(task1: Task<T1>, task2: Task<T2>, task3: Task<T3>, task4: Task<T4>): Task<[T1, T2, T3, T4]>;
declare function all<T>(...tasks: Task<T>[]): Task<T[]>;
export declare const wrap: <T>(run: () => Promise<T>) => Task<T>;
export declare const r: (strings: TemplateStringsArray, ...stringsOrTasksOrPromises: (string | Promise<string> | Task<string>)[]) => Task<void>;
declare type Tasks<T> = {
    [P in keyof T]: Task<void>;
} & object;
export declare const start: <T extends Tasks<T>>(tasksOrFunction: T | (() => Promise<T>)) => void;
