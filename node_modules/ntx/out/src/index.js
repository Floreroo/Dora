"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const childProcess = require("child_process");
const path = require("path");
const chokidar = require("chokidar");
const util_1 = require("util");
//#region utils
const execAsync = util_1.promisify(childProcess.exec);
class ProcessExitCodeError extends Error {
    constructor(code, signal) {
        super(`Process exited with non-zero code. code: ${code}, signal: ${signal}`);
        this.code = code;
        this.signal = signal;
    }
}
exports.ProcessExitCodeError = ProcessExitCodeError;
const spawnAsync = (command, args, onOutputReceived, onErrorReceived) => {
    return new Promise((resolve, reject) => {
        const p = childProcess.spawn(command, args, { shell: true });
        if (onErrorReceived != null) {
            p.stderr.on("data", onErrorReceived);
        }
        if (onOutputReceived != null) {
            p.stdout.on("data", onOutputReceived);
        }
        p.on("close", (code, signal) => {
            p.removeAllListeners();
            if (code !== 0) {
                reject(new ProcessExitCodeError(code, signal));
            }
            else {
                resolve();
            }
        });
        p.on("error", error => {
            p.removeAllListeners();
            reject(error);
        });
    });
};
const npmBinPath = execAsync("npm bin").then(r => r.stdout.trim());
//#endregion
//#region task
const combineName = (env, name) => name ? Object.assign(Object.assign({}, env), { name: `${env.name}.${name}` }) : env;
/** @internal */
exports._makeOnChange = (f) => {
    const queue = [];
    let running = false;
    function receive() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            running = true;
            while (queue.length !== 0) {
                const xs = queue.slice();
                queue.length = 0;
                yield f(xs);
            }
            running = false;
        });
    }
    return (x, reject) => {
        queue.push(x);
        if (running === false) {
            receive().catch(reject);
        }
    };
};
class TaskImpl {
    constructor(name, run) {
        this.name = name;
        this.run = run;
    }
    withName(name) { return new TaskImpl(name, this.run); }
    then(continuation) {
        return new TaskImpl(this.name, (e) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.run(combineName(e, this.name));
            return continuation.run(combineName(e, continuation.name));
        }));
    }
    let(continuation) {
        return toTask((e) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const t = continuation(yield this.run(combineName(e, this.name)));
            return t.run(combineName(e, t.name));
        }));
    }
    watch(glob) {
        return new TaskImpl(this.name, env => new Promise((_resolve, reject) => {
            const onchange = exports._makeOnChange(() => this.run(env));
            const w = chokidar.watch(glob, { persistent: true });
            w.once("error", e => {
                w.removeAllListeners();
                w.close();
                reject(e);
            });
            w.on("all", (event, path) => {
                onchange({ event, path }, reject);
            });
        }));
    }
    start() {
        const name = this.name || "_";
        console.log(`> ${name} ${process.cwd()}`);
        handleError(this.run({ name }));
    }
}
const setTimeoutAsync = util_1.promisify(setTimeout);
exports.sleep = (ms) => exports.wrap(() => setTimeoutAsync(ms));
const allArray = (tasks) => {
    const name1 = tasks[0].name;
    return new TaskImpl(name1 === void 0 ? null : name1, env => {
        let es = tasks.map(t => combineName(env, t.name));
        if (new Set(es.map(e => e.name)).size !== es.length) {
            es = es.map((e, i) => (Object.assign(Object.assign({}, e), { name: `${env.name}.${i + 1}` })));
        }
        return Promise.all(tasks.map((t, i) => t.run(es[i])));
    });
};
function all(taskArrayOrTask1, ...tasksTail) {
    if (Array.isArray(taskArrayOrTask1)) {
        return allArray(taskArrayOrTask1);
    }
    else {
        tasksTail.unshift(taskArrayOrTask1);
        return allArray(tasksTail);
    }
}
exports.all = all;
const toTask = (run) => new TaskImpl(null, run);
exports.wrap = (run) => toTask(() => run());
const overrideEnvAsync = (key, value, action) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const oldValue = process.env[key];
    process.env[key] = value;
    const result = yield action();
    process.env[key] = oldValue;
    return result;
});
exports.r = (strings, ...stringsOrTasksOrPromises) => toTask((e) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const xs = [strings[0]];
    for (let i = 0, l = stringsOrTasksOrPromises.length; i < l; i++) {
        const v = stringsOrTasksOrPromises[i];
        const s = (typeof v === "string") ? v :
            (v instanceof Promise) ? yield v :
                yield v.run(e);
        xs.push(s);
        xs.push(strings[i + 1]);
    }
    const name = e.name;
    const command = xs.join("");
    console.log(`${name}> ${command}`);
    return overrideEnvAsync("path", process.env.path + ";" + (yield npmBinPath), () => spawnAsync(command, [], s => {
        process.stdout.write(`${name}> `);
        process.stdout.write(s);
    }, s => {
        process.stderr.write(`${name}> `);
        process.stderr.write(s);
    }));
}));
const startAsync = (tasksOrFunction) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const tasks = (typeof tasksOrFunction === "function") ? yield tasksOrFunction() : tasksOrFunction;
    const taskName = process.argv[2];
    const taskNames = Object.keys(tasks);
    const getAvailableTasksMessage = (ks) => `available tasks: ${ks.map(k => `'${k}'`).join(" ")}`;
    if (taskName === void 0) {
        const [name0] = taskNames;
        const egName = (name0 == null || name0 == "") ? "any_task_name" : (/\w[\w:]*/.test(name0)) ? name0 : `'${name0}'`;
        throw new Error(`require task name. e.g. \`node ${path.basename(process.argv[1])} ${egName}\`. ${getAvailableTasksMessage(taskNames)}.`);
    }
    if (taskNames.indexOf(taskName) === -1) {
        throw new Error(`task '${taskName}' is not defined. ${getAvailableTasksMessage(taskNames)}.`);
    }
    const task = tasks[taskName];
    return task.withName(taskName).start();
});
const handleError = (p) => { p.catch(e => console.error(e)); };
exports.start = (tasksOrFunction) => handleError(startAsync(tasksOrFunction));
//#endregion
